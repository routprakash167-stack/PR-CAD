<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PR CAD</title>

<style>
body{
    margin:0;
    background:#111;
    color:white;
    font-family:Arial;
    overflow:hidden;
}

#toolbar{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:50px;
    background:#1b1b1b;
    display:flex;
    align-items:center;
    gap:5px;
    padding:5px;
    z-index:10;
}

button{
    background:#333;
    color:white;
    border:none;
    padding:6px 10px;
    cursor:pointer;
}

button:hover{
    background:#555;
}

#colorPicker{
    width:40px;
    height:30px;
}

canvas{
    position:absolute;
    top:50px;
    left:0;
}
</style>
</head>

<body>

<div id="toolbar">
<button onclick="setTool('select')">Select</button>
<button onclick="setTool('line')">Line</button>
<button onclick="setTool('polyline')">Polyline</button>
<button onclick="setTool('rectangle')">Rect</button>
<button onclick="setTool('square')">Square</button>
<button onclick="setTool('circle')">Circle</button>
<button onclick="setTool('ellipse')">Ellipse</button>
<button onclick="setTool('arc')">Arc</button>
<button onclick="setTool('polygon')">Polygon</button>
<button onclick="setTool('ray')">Ray</button>
<button onclick="setTool('xline')">XLine</button>
<button onclick="setTool('trim')">Trim</button>
<button onclick="deleteSelected()">Delete</button>
<button onclick="saveProject()">Save</button>
<button onclick="loadProject()">Load</button>
<input type="color" id="colorPicker">
</div>

<canvas id="canvas"></canvas>

<script>

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 50;

let entities = [];
let currentTool = "line";
let drawing = false;
let startPoint = null;
let tempPoint = null;
let selected = null;

let scale = 1;
let offsetX = 0;
let offsetY = 0;

let currentColor = "#ffffff";

document.getElementById("colorPicker").addEventListener("input", e=>{
    currentColor = e.target.value;
});

function setTool(t){
    currentTool = t;
}

function worldToScreen(x,y){
    return {
        x: x*scale + offsetX,
        y: y*scale + offsetY
    };
}

function screenToWorld(x,y){
    return {
        x:(x-offsetX)/scale,
        y:(y-offsetY)/scale
    };
}

function drawGrid(){
    ctx.strokeStyle="#222";
    ctx.lineWidth=1;
    let step = 50*scale;

    for(let x=offsetX%step;x<canvas.width;x+=step){
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,canvas.height);
        ctx.stroke();
    }

    for(let y=offsetY%step;y<canvas.height;y+=step){
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(canvas.width,y);
        ctx.stroke();
    }
}

function redraw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();

    entities.forEach(e=>{
        ctx.strokeStyle=e.color;
        ctx.lineWidth=2;

        if(e.type==="line"){
            let p1=worldToScreen(e.start.x,e.start.y);
            let p2=worldToScreen(e.end.x,e.end.y);
            ctx.beginPath();
            ctx.moveTo(p1.x,p1.y);
            ctx.lineTo(p2.x,p2.y);
            ctx.stroke();
        }

        if(e.type==="circle"){
            let c=worldToScreen(e.center.x,e.center.y);
            ctx.beginPath();
            ctx.arc(c.x,c.y,e.radius*scale,0,Math.PI*2);
            ctx.stroke();
        }

        if(e.type==="ellipse"){
            let c=worldToScreen(e.center.x,e.center.y);
            ctx.beginPath();
            ctx.ellipse(c.x,c.y,e.rx*scale,e.ry*scale,0,0,Math.PI*2);
            ctx.stroke();
        }

        if(e.type==="arc"){
            let c=worldToScreen(e.center.x,e.center.y);
            ctx.beginPath();
            ctx.arc(c.x,c.y,e.radius*scale,e.start,e.end);
            ctx.stroke();
        }
    });

    if(selected){
        ctx.strokeStyle="yellow";
        ctx.lineWidth=3;
        let p1=worldToScreen(selected.start.x,selected.start.y);
        let p2=worldToScreen(selected.end.x,selected.end.y);
        ctx.beginPath();
        ctx.moveTo(p1.x,p1.y);
        ctx.lineTo(p2.x,p2.y);
        ctx.stroke();
    }
}

canvas.addEventListener("mousedown", e=>{
    const pos=screenToWorld(e.offsetX,e.offsetY);
    drawing=true;
    startPoint=pos;

    if(currentTool==="select"){
        selected=findLineNear(pos);
    }

    if(currentTool==="trim"){
        trimAtPoint(pos);
    }
});

canvas.addEventListener("mousemove", e=>{
    if(!drawing) return;
    tempPoint=screenToWorld(e.offsetX,e.offsetY);
    redraw();

    if(currentTool==="line"){
        let p1=worldToScreen(startPoint.x,startPoint.y);
        let p2=worldToScreen(tempPoint.x,tempPoint.y);
        ctx.strokeStyle=currentColor;
        ctx.beginPath();
        ctx.moveTo(p1.x,p1.y);
        ctx.lineTo(p2.x,p2.y);
        ctx.stroke();
    }
});

canvas.addEventListener("mouseup", e=>{
    if(!drawing) return;
    const end=screenToWorld(e.offsetX,e.offsetY);

    if(currentTool==="line"){
        entities.push({type:"line",start:startPoint,end:end,color:currentColor});
    }

    if(currentTool==="rectangle"){
        addRectangle(startPoint,end);
    }

    if(currentTool==="square"){
        addSquare(startPoint,end);
    }

    if(currentTool==="circle"){
        let r=Math.hypot(end.x-startPoint.x,end.y-startPoint.y);
        entities.push({type:"circle",center:startPoint,radius:r,color:currentColor});
    }

    if(currentTool==="ellipse"){
        entities.push({type:"ellipse",center:startPoint,rx:Math.abs(end.x-startPoint.x),ry:Math.abs(end.y-startPoint.y),color:currentColor});
    }

    drawing=false;
    redraw();
});

function addRectangle(p1,p2){
    entities.push({type:"line",start:{x:p1.x,y:p1.y},end:{x:p2.x,y:p1.y},color:currentColor});
    entities.push({type:"line",start:{x:p2.x,y:p1.y},end:{x:p2.x,y:p2.y},color:currentColor});
    entities.push({type:"line",start:{x:p2.x,y:p2.y},end:{x:p1.x,y:p2.y},color:currentColor});
    entities.push({type:"line",start:{x:p1.x,y:p2.y},end:{x:p1.x,y:p1.y},color:currentColor});
}

function addSquare(p1,p2){
    let size=Math.max(Math.abs(p2.x-p1.x),Math.abs(p2.y-p1.y));
    addRectangle(p1,{x:p1.x+size,y:p1.y+size});
}

function findLineNear(p){
    for(let e of entities){
        if(e.type==="line"){
            let d=distancePointToLine(p,e.start,e.end);
            if(d<5/scale) return e;
        }
    }
    return null;
}

function distancePointToLine(p,a,b){
    let A=p.x-a.x;
    let B=p.y-a.y;
    let C=b.x-a.x;
    let D=b.y-a.y;

    let dot=A*C+B*D;
    let len=C*C+D*D;
    let param=dot/len;

    let xx,yy;

    if(param<0){xx=a.x;yy=a.y;}
    else if(param>1){xx=b.x;yy=b.y;}
    else{xx=a.x+param*C;yy=a.y+param*D;}

    return Math.hypot(p.x-xx,p.y-yy);
}

function trimAtPoint(p){
    let line=findLineNear(p);
    if(!line) return;

    entities=entities.filter(e=>e!==line);
    redraw();
}

function deleteSelected(){
    if(!selected) return;
    entities=entities.filter(e=>e!==selected);
    selected=null;
    redraw();
}

function saveProject(){
    localStorage.setItem("prcad",JSON.stringify(entities));
    alert("Saved");
}

function loadProject(){
    let data=localStorage.getItem("prcad");
    if(data){
        entities=JSON.parse(data);
        redraw();
    }
}

canvas.addEventListener("wheel", e=>{
    e.preventDefault();
    const zoom=e.deltaY<0?1.1:0.9;
    scale*=zoom;
    redraw();
});

redraw();

</script>
</body>
</html>
