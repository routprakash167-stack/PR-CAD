<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PR CAD</title>
<style>
body{
    margin:0;
    overflow:hidden;
    font-family:Arial;
    background:#1e1e1e;
}
#toolbar{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    background:#2d2d2d;
    padding:5px;
    display:flex;
    flex-wrap:wrap;
    z-index:10;
}
button,input{
    margin:3px;
}
canvas{
    display:block;
}
</style>
</head>
<body>

<div id="toolbar">
    <button onclick="setTool('line')">Line</button>
    <button onclick="setTool('rectangle')">Rectangle</button>
    <button onclick="setTool('square')">Square</button>
    <button onclick="setTool('circle')">Circle</button>
    <button onclick="setTool('arc')">Arc</button>
    <button onclick="setTool('polygon')">Polygon</button>
    <button onclick="setTool('spline')">Spline</button>
    <button onclick="setTool('construction')">Construction</button>
    <button onclick="setTool('ray')">Ray</button>
    <button onclick="setTool('trim')">Trim</button>
    <input type="color" id="colorPicker" value="#ffffff">
</div>

<canvas id="canvas"></canvas>

<script>

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const colorPicker = document.getElementById("colorPicker");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let tool = "line";
let shapes = [];
let drawing = false;
let start = null;
let preview = null;

let offset = {x:0,y:0};
let scale = 1;
let gridSize = 50;

let polygonSides = 5;
let splinePoints = [];
let arcPoints = [];

function setTool(t){
    tool = t;
}

function worldToScreen(x,y){
    return {
        x: x*scale + offset.x,
        y: y*scale + offset.y
    };
}

function screenToWorld(x,y){
    return {
        x:(x-offset.x)/scale,
        y:(y-offset.y)/scale
    };
}

function drawGrid(){
    ctx.strokeStyle="#333";
    ctx.lineWidth=1;
    let step = gridSize*scale;
    for(let x=offset.x%step; x<canvas.width; x+=step){
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,canvas.height);
        ctx.stroke();
    }
    for(let y=offset.y%step; y<canvas.height; y+=step){
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(canvas.width,y);
        ctx.stroke();
    }
}

function drawShapes(){
    shapes.forEach(s=>{
        ctx.strokeStyle=s.color;
        ctx.lineWidth=2;
        ctx.beginPath();
        if(s.type==="line" || s.type==="construction" || s.type==="ray"){
            let p1=worldToScreen(s.x1,s.y1);
            let p2=worldToScreen(s.x2,s.y2);
            ctx.moveTo(p1.x,p1.y);
            ctx.lineTo(p2.x,p2.y);
        }
        if(s.type==="rectangle" || s.type==="square"){
            let p=worldToScreen(s.x,s.y);
            ctx.strokeRect(p.x,p.y,s.w*scale,s.h*scale);
        }
        if(s.type==="circle"){
            let p=worldToScreen(s.x,s.y);
            ctx.arc(p.x,p.y,s.r*scale,0,Math.PI*2);
        }
        if(s.type==="polygon"){
            s.points.forEach((pt,i)=>{
                let p=worldToScreen(pt.x,pt.y);
                if(i===0) ctx.moveTo(p.x,p.y);
                else ctx.lineTo(p.x,p.y);
            });
            ctx.closePath();
        }
        ctx.stroke();
    });
}

function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    drawShapes();
    if(preview){
        ctx.strokeStyle=colorPicker.value;
        ctx.beginPath();
        preview();
        ctx.stroke();
    }
}

canvas.addEventListener("mousedown",e=>{
    let pos=screenToWorld(e.clientX,e.clientY);

    if(tool==="trim"){
        trimAt(pos);
        return;
    }

    drawing=true;
    start=pos;

    if(tool==="spline"){
        splinePoints.push(pos);
    }
    if(tool==="arc"){
        arcPoints.push(pos);
    }
});

canvas.addEventListener("mousemove",e=>{
    if(!drawing) return;
    let pos=screenToWorld(e.clientX,e.clientY);

    preview=function(){
        let p1=worldToScreen(start.x,start.y);
        let p2=worldToScreen(pos.x,pos.y);

        if(tool==="line"||tool==="construction"||tool==="ray"){
            ctx.moveTo(p1.x,p1.y);
            ctx.lineTo(p2.x,p2.y);
        }
        if(tool==="rectangle"){
            ctx.strokeRect(p1.x,p1.y,(pos.x-start.x)*scale,(pos.y-start.y)*scale);
        }
        if(tool==="square"){
            let size=Math.max(pos.x-start.x,pos.y-start.y);
            ctx.strokeRect(p1.x,p1.y,size*scale,size*scale);
        }
        if(tool==="circle"){
            let r=Math.hypot(pos.x-start.x,pos.y-start.y);
            ctx.arc(p1.x,p1.y,r*scale,0,Math.PI*2);
        }
    };
    render();
});

canvas.addEventListener("mouseup",e=>{
    if(!drawing) return;
    drawing=false;
    let pos=screenToWorld(e.clientX,e.clientY);

    if(tool==="line"||tool==="construction"||tool==="ray"){
        shapes.push({type:tool,x1:start.x,y1:start.y,x2:pos.x,y2:pos.y,color:colorPicker.value});
    }
    if(tool==="rectangle"){
        shapes.push({type:"rectangle",x:start.x,y:start.y,w:pos.x-start.x,h:pos.y-start.y,color:colorPicker.value});
    }
    if(tool==="square"){
        let size=Math.max(pos.x-start.x,pos.y-start.y);
        shapes.push({type:"square",x:start.x,y:start.y,w:size,h:size,color:colorPicker.value});
    }
    if(tool==="circle"){
        let r=Math.hypot(pos.x-start.x,pos.y-start.y);
        shapes.push({type:"circle",x:start.x,y:start.y,r:r,color:colorPicker.value});
    }

    preview=null;
    render();
});

function trimAt(pos){
    let tolerance=5/scale;
    shapes=shapes.flatMap(s=>{
        if(s.type==="line"){
            let dx=s.x2-s.x1;
            let dy=s.y2-s.y1;
            let length=Math.hypot(dx,dy);
            let t=((pos.x-s.x1)*dx+(pos.y-s.y1)*dy)/(length*length);
            if(t>0 && t<1){
                let nx=s.x1+t*dx;
                let ny=s.y1+t*dy;
                return [
                    {type:"line",x1:s.x1,y1:s.y1,x2:nx,y2:ny,color:s.color},
                    {type:"line",x1:nx,y1:ny,x2:s.x2,y2:s.y2,color:s.color}
                ];
            }
        }
        return [s];
    });
    render();
}

canvas.addEventListener("wheel",e=>{
    e.preventDefault();
    let zoom=e.deltaY<0?1.1:0.9;
    scale*=zoom;
    render();
});

let isPanning=false;
canvas.addEventListener("contextmenu",e=>e.preventDefault());
canvas.addEventListener("mousedown",e=>{
    if(e.button===2){
        isPanning=true;
    }
});
canvas.addEventListener("mousemove",e=>{
    if(isPanning){
        offset.x+=e.movementX;
        offset.y+=e.movementY;
        render();
    }
});
canvas.addEventListener("mouseup",()=>isPanning=false);

render();

</script>
</body>
</html>
