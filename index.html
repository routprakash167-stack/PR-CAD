<!DOCTYPE html>
<html>
<head>
<title>PR CAD - 2D Design Studio</title>

<style>
body{
  margin:0;
  background:#0f0f0f;
  color:white;
  font-family:Arial;
  overflow:hidden;
}

header{
  background:#111;
  padding:12px;
  text-align:center;
  font-size:20px;
  font-weight:bold;
  color:cyan;
}

.toolbar{
  background:#1a1a1a;
  padding:8px;
  display:flex;
  gap:8px;
  justify-content:center;
  flex-wrap:wrap;
}

button{
  background:#222;
  color:white;
  border:1px solid cyan;
  padding:6px 12px;
  cursor:pointer;
}

button:hover{
  background:cyan;
  color:black;
}

canvas{
  display:block;
  background:#000;
  touch-action:none;
}
</style>
</head>

<body>

<header>PR CAD - Infinite 2D Engine</header>

<div class="toolbar">
  <button onclick="setTool('line')">Line</button>
  <button onclick="setTool('rect')">Rectangle</button>
  <button onclick="setTool('circle')">Circle</button>
  <button onclick="setTool('trim')">Trim</button>
  <button onclick="clearCanvas()">Clear</button>
  <button onclick="saveProject()">Save</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 90;

/* ================= ENGINE STORAGE ================= */
let edges = [];   // universal storage

/* ================= STATE ================= */
let tool = "line";
let drawing = false;
let startPoint = null;
let previewEdges = [];

let offset = {x:0,y:0};
let scale = 1;
let gridSize = 25;

let isPanning = false;
let panStart = null;

/* ================= TOOL ================= */
function setTool(t){ tool = t; }

/* ================= COORDINATES ================= */
function toWorld(x,y){
  return { x:(x/scale)+offset.x, y:(y/scale)+offset.y };
}

function toScreen(x,y){
  return { x:(x-offset.x)*scale, y:(y-offset.y)*scale };
}

function snap(v){ return Math.round(v/gridSize)*gridSize; }

/* ================= GRID ================= */
function drawGrid(){
  ctx.strokeStyle="#111";
  ctx.lineWidth=1;

  let left=offset.x;
  let right=offset.x+canvas.width/scale;
  let top=offset.y;
  let bottom=offset.y+canvas.height/scale;

  for(let x=Math.floor(left/gridSize)*gridSize;x<right;x+=gridSize){
    let s=toScreen(x,0);
    ctx.beginPath();
    ctx.moveTo(s.x,0);
    ctx.lineTo(s.x,canvas.height);
    ctx.stroke();
  }

  for(let y=Math.floor(top/gridSize)*gridSize;y<bottom;y+=gridSize){
    let s=toScreen(0,y);
    ctx.beginPath();
    ctx.moveTo(0,s.y);
    ctx.lineTo(canvas.width,s.y);
    ctx.stroke();
  }
}

/* ================= DRAW EDGES ================= */
function drawEdge(e,color="cyan"){
  ctx.strokeStyle=color;
  ctx.lineWidth=2;
  let p1=toScreen(e.x1,e.y1);
  let p2=toScreen(e.x2,e.y2);
  ctx.beginPath();
  ctx.moveTo(p1.x,p1.y);
  ctx.lineTo(p2.x,p2.y);
  ctx.stroke();
}

function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  edges.forEach(e=>drawEdge(e));
  previewEdges.forEach(e=>drawEdge(e,"yellow"));
}

/* ================= EVENTS ================= */
canvas.addEventListener("mousedown",startDraw);
canvas.addEventListener("mousemove",moveDraw);
canvas.addEventListener("mouseup",endDraw);
canvas.addEventListener("wheel",zoom);
canvas.addEventListener("contextmenu",e=>e.preventDefault());

function getMouse(e){
  const rect=canvas.getBoundingClientRect();
  return { x:e.clientX-rect.left, y:e.clientY-rect.top };
}

function startDraw(e){

  if(e.button===2){
    isPanning=true;
    panStart=getMouse(e);
    return;
  }

  let m=getMouse(e);
  let w=toWorld(m.x,m.y);

  if(tool==="trim"){
    trimSegment(w.x,w.y);
    return;
  }

  drawing=true;
  startPoint={ x:snap(w.x), y:snap(w.y) };
}

function moveDraw(e){

  if(isPanning){
    let m=getMouse(e);
    offset.x-= (m.x-panStart.x)/scale;
    offset.y-= (m.y-panStart.y)/scale;
    panStart=m;
    redraw();
    return;
  }

  if(!drawing) return;

  previewEdges=[];
  let m=getMouse(e);
  let w=toWorld(m.x,m.y);
  w.x=snap(w.x);
  w.y=snap(w.y);

  if(tool==="line"){
    previewEdges.push({x1:startPoint.x,y1:startPoint.y,x2:w.x,y2:w.y});
  }

  if(tool==="rect"){
    previewEdges.push({x1:startPoint.x,y1:startPoint.y,x2:w.x,y2:startPoint.y});
    previewEdges.push({x1:w.x,y1:startPoint.y,x2:w.x,y2:w.y});
    previewEdges.push({x1:w.x,y1:w.y,x2:startPoint.x,y2:w.y});
    previewEdges.push({x1:startPoint.x,y1:w.y,x2:startPoint.x,y2:startPoint.y});
  }

  if(tool==="circle"){
    let r=Math.hypot(w.x-startPoint.x,w.y-startPoint.y);
    let segments=60;
    for(let i=0;i<segments;i++){
      let a1=(i/segments)*Math.PI*2;
      let a2=((i+1)/segments)*Math.PI*2;
      previewEdges.push({
        x1:startPoint.x+Math.cos(a1)*r,
        y1:startPoint.y+Math.sin(a1)*r,
        x2:startPoint.x+Math.cos(a2)*r,
        y2:startPoint.y+Math.sin(a2)*r
      });
    }
  }

  redraw();
}

function endDraw(){
  if(isPanning){ isPanning=false; return; }
  if(!drawing) return;
  drawing=false;

  edges.push(...previewEdges);
  previewEdges=[];
  redraw();
}

/* ================= ZOOM ================= */
function zoom(e){
  e.preventDefault();
  const zoomFactor=1.1;
  const mouse=toWorld(e.offsetX,e.offsetY);

  if(e.deltaY<0) scale*=zoomFactor;
  else scale/=zoomFactor;

  offset.x=mouse.x-(e.offsetX/scale);
  offset.y=mouse.y-(e.offsetY/scale);
  redraw();
}

/* ================= UNIVERSAL TRIM ================= */
function trimSegment(mx,my){

  for(let i=0;i<edges.length;i++){

    let line=edges[i];
    let intersections=[];

    for(let j=0;j<edges.length;j++){
      if(i===j) continue;
      let pt=lineIntersection(line,edges[j]);
      if(pt) intersections.push(pt);
    }

    intersections.push({x:line.x1,y:line.y1});
    intersections.push({x:line.x2,y:line.y2});

    intersections.sort((a,b)=>
      distance(line.x1,line.y1,a.x,a.y)-
      distance(line.x1,line.y1,b.x,b.y)
    );

    for(let k=0;k<intersections.length-1;k++){

      let p1=intersections[k];
      let p2=intersections[k+1];

      if(pointNearLine(mx,my,p1.x,p1.y,p2.x,p2.y)){

        edges.splice(i,1);

        if(distance(line.x1,line.y1,p1.x,p1.y)>1)
          edges.push({x1:line.x1,y1:line.y1,x2:p1.x,y2:p1.y});

        if(distance(p2.x,p2.y,line.x2,line.y2)>1)
          edges.push({x1:p2.x,y1:p2.y,x2:line.x2,y2:line.y2});

        redraw();
        return;
      }
    }
  }
}

/* ================= MATH ================= */
function distance(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }

function pointNearLine(mx,my,x1,y1,x2,y2){
  const threshold=8;
  let A=mx-x1,B=my-y1,C=x2-x1,D=y2-y1;
  let dot=A*C+B*D;
  let len=C*C+D*D;
  let param=dot/len;
  if(param<0||param>1) return false;
  let xx=x1+param*C;
  let yy=y1+param*D;
  return distance(mx,my,xx,yy)<threshold/scale;
}

function lineIntersection(l1,l2){
  let {x1,y1,x2,y2}=l1;
  let x3=l2.x1,y3=l2.y1,x4=l2.x2,y4=l2.y2;
  let denom=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
  if(denom===0) return null;
  let px=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/denom;
  let py=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/denom;
  if(px<Math.min(x1,x2)-1||px>Math.max(x1,x2)+1) return null;
  if(px<Math.min(x3,x4)-1||px>Math.max(x3,x4)+1) return null;
  if(py<Math.min(y1,y2)-1||py>Math.max(y1,y2)+1) return null;
  if(py<Math.min(y3,y4)-1||py>Math.max(y3,y4)+1) return null;
  return {x:px,y:py};
}

/* ================= SAVE ================= */
function saveProject(){
  localStorage.setItem("prcad_project",JSON.stringify(edges));
  alert("Project Saved");
}

function clearCanvas(){
  edges=[];
  redraw();
}

let saved=localStorage.getItem("prcad_project");
if(saved) edges=JSON.parse(saved);

redraw();
</script>

</body>
</html>
