<!DOCTYPE html>
<html>
<head>
<title>PR CAD - 2D Design Studio</title>

<style>
body{
  margin:0;
  background:#0f0f0f;
  color:white;
  font-family:Arial;
  overflow:hidden;
}

header{
  background:#111;
  padding:12px;
  text-align:center;
  font-size:20px;
  font-weight:bold;
  color:cyan;
}

.toolbar{
  background:#1a1a1a;
  padding:8px;
  display:flex;
  gap:8px;
  justify-content:center;
  flex-wrap:wrap;
}

button{
  background:#222;
  color:white;
  border:1px solid cyan;
  padding:6px 12px;
  cursor:pointer;
}

button:hover{
  background:cyan;
  color:black;
}

canvas{
  display:block;
  background:#000;
  touch-action:none;
}
</style>
</head>

<body>

<header>PR CAD - Infinite 2D Engine</header>

<div class="toolbar">
  <button onclick="setTool('line')">Line</button>
  <button onclick="setTool('rect')">Rectangle</button>
  <button onclick="setTool('circle')">Circle</button>
  <button onclick="setTool('trim')">Trim</button>
  <button onclick="clearCanvas()">Clear</button>
  <button onclick="saveProject()">Save</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 90;

let tool = "line";
let drawing = false;
let startPoint = null;
let preview = null;
let shapes = [];

let offset = {x:0,y:0};
let scale = 1;
let gridSize = 25;

let isPanning = false;
let panStart = null;

/* ============================
   TOOL
============================ */
function setTool(t){ tool = t; }

/* ============================
   COORDINATE SYSTEM
============================ */
function toWorld(x,y){
  return {
    x:(x/scale)+offset.x,
    y:(y/scale)+offset.y
  };
}

function toScreen(x,y){
  return {
    x:(x-offset.x)*scale,
    y:(y-offset.y)*scale
  };
}

function snap(v){
  return Math.round(v/gridSize)*gridSize;
}

/* ============================
   GRID
============================ */
function drawGrid(){
  ctx.strokeStyle="#111";
  ctx.lineWidth=1;

  let left=offset.x;
  let right=offset.x+canvas.width/scale;
  let top=offset.y;
  let bottom=offset.y+canvas.height/scale;

  for(let x=Math.floor(left/gridSize)*gridSize;x<right;x+=gridSize){
    let s=toScreen(x,0);
    ctx.beginPath();
    ctx.moveTo(s.x,0);
    ctx.lineTo(s.x,canvas.height);
    ctx.stroke();
  }

  for(let y=Math.floor(top/gridSize)*gridSize;y<bottom;y+=gridSize){
    let s=toScreen(0,y);
    ctx.beginPath();
    ctx.moveTo(0,s.y);
    ctx.lineTo(canvas.width,s.y);
    ctx.stroke();
  }
}

/* ============================
   DRAW SHAPES
============================ */
function drawShape(s,color="cyan"){
  ctx.strokeStyle=color;
  ctx.lineWidth=2;

  if(s.type==="line"){
    let p1=toScreen(s.x1,s.y1);
    let p2=toScreen(s.x2,s.y2);
    ctx.beginPath();
    ctx.moveTo(p1.x,p1.y);
    ctx.lineTo(p2.x,p2.y);
    ctx.stroke();
  }

  if(s.type==="rect"){
    let p=toScreen(s.x1,s.y1);
    ctx.strokeRect(p.x,p.y,s.w*scale,s.h*scale);
  }

  if(s.type==="circle"){
    let p=toScreen(s.x1,s.y1);
    ctx.beginPath();
    ctx.arc(p.x,p.y,s.r*scale,0,Math.PI*2);
    ctx.stroke();
  }
}

function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  shapes.forEach(s=>drawShape(s));
  if(preview) drawShape(preview,"yellow");
}

/* ============================
   EVENTS
============================ */
canvas.addEventListener("mousedown",startDraw);
canvas.addEventListener("mousemove",moveDraw);
canvas.addEventListener("mouseup",endDraw);
canvas.addEventListener("wheel",zoom);
canvas.addEventListener("contextmenu",e=>e.preventDefault());

function getMouse(e){
  const rect=canvas.getBoundingClientRect();
  return {
    x:e.clientX-rect.left,
    y:e.clientY-rect.top
  };
}

function startDraw(e){

  if(e.button===2){   // Right click = pan
    isPanning=true;
    panStart=getMouse(e);
    return;
  }

  if(tool==="trim"){
    let m=getMouse(e);
    let w=toWorld(m.x,m.y);
    trimAt(w.x,w.y);
    return;
  }

  drawing=true;
  let m=getMouse(e);
  let w=toWorld(m.x,m.y);
  startPoint={
    x:snap(w.x),
    y:snap(w.y)
  };
}

function moveDraw(e){

  if(isPanning){
    let m=getMouse(e);
    offset.x-= (m.x-panStart.x)/scale;
    offset.y-= (m.y-panStart.y)/scale;
    panStart=m;
    redraw();
    return;
  }

  if(!drawing) return;

  let m=getMouse(e);
  let w=toWorld(m.x,m.y);
  w.x=snap(w.x);
  w.y=snap(w.y);

  if(tool==="line"){
    preview={
      type:"line",
      x1:startPoint.x,
      y1:startPoint.y,
      x2:w.x,
      y2:w.y
    };
  }

  if(tool==="rect"){
    preview={
      type:"rect",
      x1:startPoint.x,
      y1:startPoint.y,
      w:w.x-startPoint.x,
      h:w.y-startPoint.y
    };
  }

  if(tool==="circle"){
    let r=Math.sqrt(
      Math.pow(w.x-startPoint.x,2)+
      Math.pow(w.y-startPoint.y,2)
    );

    preview={
      type:"circle",
      x1:startPoint.x,
      y1:startPoint.y,
      r:r
    };
  }

  redraw();
}

function endDraw(e){
  if(isPanning){ isPanning=false; return; }

  if(!drawing) return;
  drawing=false;

  if(preview) shapes.push(preview);
  preview=null;
  redraw();
}

/* ============================
   ZOOM
============================ */
function zoom(e){
  e.preventDefault();
  const zoomFactor=1.1;
  const mouse=toWorld(e.offsetX,e.offsetY);

  if(e.deltaY<0) scale*=zoomFactor;
  else scale/=zoomFactor;

  offset.x=mouse.x-(e.offsetX/scale);
  offset.y=mouse.y-(e.offsetY/scale);

  redraw();
}

/* ============================
   TRIM
============================ */
function trimSegment(mouseX, mouseY) {

    const threshold = 6;

    for (let i = 0; i < shapes.length; i++) {

        let shape = shapes[i];

        if (shape.type !== "line") continue;

        // Collect intersection points
        let intersections = [];

        for (let j = 0; j < shapes.length; j++) {
            if (i === j) continue;

            let other = shapes[j];
            if (other.type !== "line") continue;

            let pt = lineIntersection(shape, other);
            if (pt) intersections.push(pt);
        }

        // Add start & end points
        intersections.push({x: shape.x1, y: shape.y1});
        intersections.push({x: shape.x2, y: shape.y2});

        // Sort points along line
        intersections.sort((a, b) => {
            return distance(shape.x1, shape.y1, a.x, a.y) -
                   distance(shape.x1, shape.y1, b.x, b.y);
        });

        // Check each segment
        for (let k = 0; k < intersections.length - 1; k++) {

            let p1 = intersections[k];
            let p2 = intersections[k + 1];

            if (pointNearLine(mouseX, mouseY, p1.x, p1.y, p2.x, p2.y)) {

                // Remove original line
                shapes.splice(i, 1);

                // Add first part if valid
                if (distance(shape.x1, shape.y1, p1.x, p1.y) > 1) {
                    shapes.push({
                        type: "line",
                        x1: shape.x1,
                        y1: shape.y1,
                        x2: p1.x,
                        y2: p1.y
                    });
                }

                // Add second part if valid
                if (distance(p2.x, p2.y, shape.x2, shape.y2) > 1) {
                    shapes.push({
                        type: "line",
                        x1: p2.x,
                        y1: p2.y,
                        x2: shape.x2,
                        y2: shape.y2
                    });
                }

                redraw();
                return;
            }
        }
    }
}

/* ============================
   SAVE / CLEAR
============================ */
function saveProject(){
  localStorage.setItem("prcad_project",JSON.stringify(shapes));
  alert("Project Saved");
}

function clearCanvas(){
  shapes=[];
  redraw();
}

redraw();

 function lineIntersection(l1, l2) {

    let x1 = l1.x1, y1 = l1.y1;
    let x2 = l1.x2, y2 = l1.y2;
    let x3 = l2.x1, y3 = l2.y1;
    let x4 = l2.x2, y4 = l2.y2;

    let denom = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
    if (denom === 0) return null;

    let px = ((x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)) / denom;
    let py = ((x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)) / denom;

    if (
        px < Math.min(x1,x2)-1 || px > Math.max(x1,x2)+1 ||
        px < Math.min(x3,x4)-1 || px > Math.max(x3,x4)+1 ||
        py < Math.min(y1,y2)-1 || py > Math.max(y1,y2)+1 ||
        py < Math.min(y3,y4)-1 || py > Math.max(y3,y4)+1
    ) return null;

    return {x: px, y: py};
} 
</script>

</body>
</html>
